---
layout: post
title: "Trufflehog Shallow Clone Insecurity: Part III - Exploitation"
date: 2024-12-22
tags: ["github"]
published: true
---

**Contents**
* TOC
{:toc}

# Problem Statement

Following a compromised Github Action via shell injection, what exploitation is possible and how does this impact Trufflehog-related workflows?

# Exploration

Trufflehog's general usage documentation uses the `pull_request`[^1] event trigger. A cursory search on Github confirms that `pull_request` is the primary event trigger used by repos.

So what's possible with `pull_request`? Forked PRs on public repos are read-only with no access to secrets. Additionally, first time forked PRs on public repos need to be manually approved before a workflow will trigger.[^2] This step can be circumvented by any PR approval, such as fixing a typo in a README file, before the actual malicious PR is submitted. 

The following attack scenarios are still possible.[^3]

* Access masked environment variables
* Github workflow cache blasting and poisoning
* Secondary workflows triggered: `workflow_run`, `required_workflows`

{:refdef: style="text-align: center;"}
![Image]({{ site.baseurl }}/assets/images/github-action.png)
{: refdef}
{:refdef: style="text-align: center;"}
\[Simplified Github Action Attack Diagram\][^4]
{: refdef}

#### Access masked environment variables

The read-only GITHUB_TOKEN could be compromised, but this wouldn't grant much access. By default the workflow run logs will mask the GITHUB_TOKEN, but an attacker could still read the env variable via bash.

Workflows triggered by `pull_requests` from forked public repos don't have access to secrets and therefore can't load secrets. 

But what if there's an environment variable that hold a credential that doesn't come from Github Secrets? Maybe the credential is stored in AWS Paramstore or Secret Manager and is regularly dynamically generated. This means the cred must be fetched on each workflow run. 

An example of this would an Github App Token. This token is dynamically generated and only lasts an hour. If a workflow leverages a Github App Token[^5], this token should ideally be stored in Github Secrets. A workflow triggered from forked PR from a public repo that tries to retrieve the secret won't have access and will likely fail.

However another pattern is for the Github App Token to be saved in Paramstore or Secret Manager and then loaded by the workflow. Environment variables are normally readable in the workflow run logs, but can optionally be masked. The danger is that a malicious forked PR could read these masked credentials. 

#### Github workflow cache blasting and poisoning

The definitive guide for this technique can be found here: [https://adnanthekhan.com/2024/05/06/the-monsters-in-your-build-cache-github-actions-cache-poisoning/](https://adnanthekhan.com/2024/05/06/the-monsters-in-your-build-cache-github-actions-cache-poisoning/)[^6]. The takeaway is that this attack scenario can be conducted on read-only GITHUB_TOKENs on `pull_request` workflows to tamper with build artifacts.

#### Secondary workflows triggered

The exploitation of `workflow_run` has been extensively documented.[^7] I haven't seen any literature of the impact on `required_workflows`. I may do some testing on `required_workflow` in the future and update this section. 

# Trufflehog Impact

This has been an initial analysis of what exploitation could be possible with the faulty Trufflehog shallow clone pattern. There doesn't seem to be an easy slam dunk  and exploitation is highly dependent on the particularities of the underlying repo and workflow. All three avenues requires more investigation on my part, but this serves as a good starting point.  

# References

[^1]: [https://github.com/trufflesecurity/trufflehog?tab=readme-ov-file#general-usage](https://github.com/trufflesecurity/trufflehog?tab=readme-ov-file#general-usage)

[^2]: Under Action > General > "Approval for running fork pull request workflows from contributors". Also, `If approval is required, a user with write access to the repository must approve the pull request workflow to be run.`. There are 3 settings available: `Require approval for first-time contributors who are new to GitHub`, `Require approval for first-time contributors`, `Require approval for all external contributors`, but all settings requires a manual approval. A good write-up here: [https://www.synacktiv.com/en/publications/github-actions-exploitation-introduction](https://www.synacktiv.com/en/publications/github-actions-exploitation-introduction)

[^3]: I'm ignoring self-hosted runners + public repos which is one of the most dangerous patterns I've ever seen. See [https://johnstawinski.com/2024/01/11/playing-with-fire-how-we-executed-a-critical-supply-chain-attack-on-pytorch/](https://johnstawinski.com/2024/01/11/playing-with-fire-how-we-executed-a-critical-supply-chain-attack-on-pytorch/) and [https://www.blackhat.com/us-24/briefings/schedule/index.html#self-hosted-github-cicd-runners-continuous-integration-continuous-destruction-38308](https://www.blackhat.com/us-24/briefings/schedule/index.html#self-hosted-github-cicd-runners-continuous-integration-continuous-destruction-38308)

[^4]: For a more in-depth attack diagram, see [https://github.com/jstawinski/GitHub-Actions-Attack-Diagram](https://github.com/jstawinski/GitHub-Actions-Attack-Diagram)

[^5]: I plan on writing another post on why this might occur

[^6]: [https://github.com/AdnaneKhan/ActionsCacheBlasting](https://github.com/AdnaneKhan/ActionsCacheBlasting)

[^7]: [https://securitylab.github.com/resources/github-actions-preventing-pwn-requests/](https://securitylab.github.com/resources/github-actions-preventing-pwn-requests/)